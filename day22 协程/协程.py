# 进程
    # 进程数据隔离，数据不安全，操作系统级别，开销非常大，能利用多核
# 线程
    # 数据共享，数据不安全，操作系统级别，开销小，cpython下不能利用多核
    # java 语言 多线程可以利用多核
    # Cpython 解释器下的的多个线程不能利用多核：就是规避了所有io操作的单线程
# 协程
    # 数据共享，数据安全（因为协程数据的切换是由用户规定的，不是操作系统决定的），开销更小，cpython下不能利用多核
        # 协程所有的切换都基于用户，只有在用户级别能够感知到的io操作才会用协程模块来规避（socket,请求网页，time.sleep)
        # 但是一些和文件操作相关的 io 只有操作系统能感知到，所以线程对 io 的感知比协程要敏感
    # 是操作系统不可见的
    # 协程本质上是一条线程，多个任务在一条线程上来回切换，
    # 利用协程的概念：来规避io操作，就达到了我们将一条线程中的io操作讲到最低的目的
    # 能供做到这种来回切换并规避io的模块有俩
    # gevent  利用了 greenlet（由c语言实现） 底层模块完成的切换 + 自动规避io的功能
    # asyncio 利用了 yield    底层模块完成的切换 + 自动规避io的功能
        # tornado 异步的web框架
        # yield from  - 为的是更好的实现协程
        # send - 更好的实现协程
        # asyncio 模块， 基于 python 原生的协程的概念正式成立
        # 特殊的，在python中提供协程功能的关键字： async, await
    # 用户级别的协程还有什么好处呢
        # 减轻了操作系统的负担
        # 一条线程如果开了多个协程，那么给操作系统一个这条线程很忙的的信号，这样能多争取一些时间片来被 CPU 执行，程序的效率就提高了

def func():
    global a
    # 协程是在代码间切换
    a += 1
    # 协程也可以在这切换

import dis
dis.dis(func)
# 对于操作系统来说： python代码 --> 编译 --> 字节码 --> 解释 --> 二进制
# 二进制 反编译过来 --> LOAD_GLOBAL ，反编译过来是为了让我们看明白


# 4cpu
# 5 个进程
# 20个 线程
# 500个 协程
# 并发数 5*20*500=50000


